---
// ChallengeComplete.astro - Modal for challenge completion notifications
---

<div
  id="challenge-complete-overlay"
  class="fixed inset-0 z-50 hidden"
  aria-hidden="true"
>
  <div
    class="absolute inset-0 bg-black/80 backdrop-blur-sm"
    data-overlay-backdrop="true"
  >
  </div>
  <div class="relative flex items-center justify-center min-h-screen p-4">
    <div
      id="challenge-complete-card"
      class="relative max-w-md w-full"
      role="dialog"
      aria-modal="true"
      aria-labelledby="challenge-name"
      tabindex="-1"
    >
      <!-- Card will be populated by JavaScript -->
    </div>
  </div>
</div>

<template id="challenge-card-template">
  <div
    class="bg-gradient-to-br from-gray-900/95 to-gray-800/95 rounded-2xl p-8 border border-cyan-500/30 shadow-2xl shadow-cyan-500/20 text-center animate-bounce-in"
  >
    <!-- XP Animation -->
    <div class="mb-4">
      <div class="text-5xl mb-2" id="challenge-icon"></div>
      <div
        class="text-2xl font-bold text-cyan-400"
        id="xp-earned"
        aria-live="polite"
        role="status"
      >
        +0 XP
      </div>
    </div>

    <!-- Challenge Info -->
    <h3
      class="text-xl font-orbitron font-bold text-white mb-2"
      id="challenge-name"
    >
      Challenge Complete!
    </h3>
    <p class="text-gray-400 mb-6" id="challenge-description"></p>

    <!-- Level Up Badge (hidden by default) -->
    <div
      id="level-up-badge"
      class="hidden mb-4 py-2 px-4 bg-gradient-to-r from-purple-600 to-pink-600 rounded-full inline-block animate-pulse"
      role="status"
      aria-live="assertive"
    >
      <span class="text-white font-bold"
        >ðŸŽ‰ LEVEL UP! Level <span id="new-level">1</span></span
      >
    </div>

    <!-- Continue button -->
    <div class="mt-6 flex justify-center">
      <button
        id="challenge-continue"
        class="px-5 py-2 rounded-full bg-cyan-500 text-white font-semibold shadow-lg shadow-cyan-500/40 hover:bg-cyan-400 focus:outline-none focus-visible:ring-2 focus-visible:ring-cyan-300 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-900 transition"
        type="button"
      >
        Continue
      </button>
    </div>

    <!-- Dismiss hint -->
    <p class="text-gray-500 text-sm mt-3">
      Click outside or press Esc to continue
    </p>
  </div>
</template>

<style>
  @keyframes bounce-in {
    0% {
      transform: scale(0.5);
      opacity: 0;
    }
    50% {
      transform: scale(1.05);
    }
    100% {
      transform: scale(1);
      opacity: 1;
    }
  }

  .animate-bounce-in {
    animation: bounce-in 0.4s ease-out forwards;
  }
</style>

<script>
  interface ChallengeCompleteData {
    completedChallenges: Array<{
      id: string
      name: string
      description: string
      icon: string
      xpReward: number
    }>
    xpEarned: number
    levelUp: boolean
    newLevel?: number
  }

  class ChallengeCompleteManager {
    private overlay: HTMLElement
    private card: HTMLElement
    private template: HTMLTemplateElement
    private queue: ChallengeCompleteData[] = []
    private isShowing = false
    private previouslyFocused: HTMLElement | null = null
    private keydownHandler = (event: KeyboardEvent) => this.handleKeydown(event)
    private autoDismissTimer: number | null = null
    private resolveDismiss?: () => void

    constructor() {
      this.overlay = document.getElementById('challenge-complete-overlay')!
      this.card = document.getElementById('challenge-complete-card')!
      this.template = document.getElementById(
        'challenge-card-template'
      ) as HTMLTemplateElement

      this.overlay.addEventListener('click', event => {
        const target = event.target as HTMLElement
        const isBackdrop =
          target === this.overlay || target.dataset.overlayBackdrop === 'true'
        if (isBackdrop) {
          this.dismiss()
        }
      })
    }

    show(data: ChallengeCompleteData): void {
      this.queue.push(data)
      if (!this.isShowing) {
        this.processQueue()
      }
    }

    private async processQueue(): Promise<void> {
      if (this.queue.length === 0) {
        this.isShowing = false
        return
      }

      const data = this.queue[0]!

      if (!data.completedChallenges.length) {
        this.isShowing = false
        this.queue.shift()
        this.processQueue()
        return
      }

      this.isShowing = true

      for (const challenge of data.completedChallenges) {
        this.renderCard(challenge, data.xpEarned, data.levelUp, data.newLevel)
        this.showOverlay()
        this.startAutoDismiss()
        await new Promise<void>(resolve => {
          this.resolveDismiss = resolve
        })
      }

      this.isShowing = false
      this.queue.shift()
      this.processQueue()
    }

    private renderCard(
      challenge: {
        name: string
        description: string
        icon: string
        xpReward: number
      },
      totalXP: number,
      levelUp: boolean,
      newLevel?: number
    ): void {
      const content = this.template.content.cloneNode(true) as DocumentFragment

      content.getElementById('challenge-icon')!.textContent = challenge.icon
      content.getElementById('xp-earned')!.textContent = `+${totalXP} XP`
      content.getElementById('challenge-name')!.textContent = challenge.name
      content.getElementById('challenge-description')!.textContent =
        challenge.description

      if (levelUp && newLevel !== undefined && newLevel !== null) {
        const badge = content.getElementById('level-up-badge')!
        badge.classList.remove('hidden')
        content.getElementById('new-level')!.textContent = String(newLevel)
      }

      this.card.innerHTML = ''
      this.card.appendChild(content)

      const continueButton = this.card.querySelector<HTMLButtonElement>(
        '#challenge-continue'
      )
      continueButton?.addEventListener('click', () => this.dismiss())
    }

    private showOverlay(): void {
      this.previouslyFocused = document.activeElement as HTMLElement | null
      this.overlay.classList.remove('hidden')
      this.overlay.setAttribute('aria-hidden', 'false')
      document.addEventListener('keydown', this.keydownHandler)
      this.setInitialFocus()
    }

    private dismiss(): void {
      this.clearAutoDismiss()
      this.overlay.classList.add('hidden')
      this.overlay.setAttribute('aria-hidden', 'true')
      document.removeEventListener('keydown', this.keydownHandler)
      this.restoreFocus()
      const resolver = this.resolveDismiss
      this.resolveDismiss = undefined
      resolver?.()
    }

    private setInitialFocus(): void {
      requestAnimationFrame(() => {
        const continueButton = this.card.querySelector<HTMLElement>(
          '#challenge-continue'
        )
        const target = continueButton || this.card
        target.focus()
      })
    }

    private getFocusableElements(): HTMLElement[] {
      const selectors =
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      return Array.from(
        this.card.querySelectorAll<HTMLElement>(selectors)
      ).filter(
        el =>
          !el.hasAttribute('disabled') &&
          el.getAttribute('aria-hidden') !== 'true' &&
          el.offsetParent !== null
      )
    }

    private handleKeydown(event: KeyboardEvent): void {
      if (!this.isShowing) {
        return
      }
      if (event.key === 'Escape') {
        event.preventDefault()
        this.dismiss()
        return
      }

      if (event.key !== 'Tab') {
        return
      }

      const focusable = this.getFocusableElements()
      if (focusable.length === 0) {
        event.preventDefault()
        this.card.focus()
        return
      }

      const first = focusable[0]
      const last = focusable[focusable.length - 1]
      const active = document.activeElement as HTMLElement | null

      if (event.shiftKey) {
        if (active === first || !this.card.contains(active)) {
          event.preventDefault()
          last.focus()
        }
      } else {
        if (active === last || !this.card.contains(active)) {
          event.preventDefault()
          first.focus()
        }
      }
    }

    private restoreFocus(): void {
      if (this.previouslyFocused && document.contains(this.previouslyFocused)) {
        this.previouslyFocused.focus()
      }
      this.previouslyFocused = null
    }

    private startAutoDismiss(): void {
      this.clearAutoDismiss()
      this.autoDismissTimer = window.setTimeout(() => this.dismiss(), 5000)
    }

    private clearAutoDismiss(): void {
      if (this.autoDismissTimer !== null) {
        window.clearTimeout(this.autoDismissTimer)
        this.autoDismissTimer = null
      }
    }
  }

  // Initialize and expose globally
  let manager: ChallengeCompleteManager
  const pendingCalls: ChallengeCompleteData[] = []

  document.addEventListener('DOMContentLoaded', () => {
    manager = new ChallengeCompleteManager()
    while (pendingCalls.length > 0) {
      const queued = pendingCalls.shift()
      if (queued) {
        manager.show(queued)
      }
    }
  })

  declare global {
    interface Window {
      showChallengeComplete?: (data: ChallengeCompleteData) => void
    }
  }

  window.showChallengeComplete = (data: ChallengeCompleteData) => {
    if (manager) {
      manager.show(data)
      return
    }
    pendingCalls.push(data)
  }
</script>
