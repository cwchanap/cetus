---
// ChallengeComplete.astro - Modal for challenge completion notifications
---

<div
  id="challenge-complete-overlay"
  class="fixed inset-0 z-50 hidden"
  aria-hidden="true"
>
  <div
    class="absolute inset-0 bg-black/80 backdrop-blur-sm"
    data-overlay-backdrop="true"
  >
  </div>
  <div class="relative flex items-center justify-center min-h-screen p-4">
    <div
      id="challenge-complete-card"
      class="relative max-w-md w-full"
      role="dialog"
      aria-modal="true"
      aria-labelledby="challenge-name"
      tabindex="-1"
    >
      <!-- Card will be populated by JavaScript -->
    </div>
  </div>
</div>

<template id="challenge-card-template">
  <div
    class="bg-gradient-to-br from-gray-900/95 to-gray-800/95 rounded-2xl p-8 border border-cyan-500/30 shadow-2xl shadow-cyan-500/20 text-center animate-bounce-in"
  >
    <!-- XP Animation -->
    <div class="mb-4">
      <div class="text-5xl mb-2" id="challenge-icon"></div>
      <div
        class="text-2xl font-bold text-cyan-400"
        id="xp-earned"
        aria-live="polite"
        role="status"
      >
        +0 XP
      </div>
    </div>

    <!-- Challenge Info -->
    <h3
      class="text-xl font-orbitron font-bold text-white mb-2"
      id="challenge-name"
    >
      Challenge Complete!
    </h3>
    <p class="text-gray-400 mb-6" id="challenge-description"></p>

    <!-- Level Up Badge (hidden by default) -->
    <div
      id="level-up-badge"
      class="hidden mb-4 py-2 px-4 bg-gradient-to-r from-purple-600 to-pink-600 rounded-full inline-block animate-pulse"
      role="status"
      aria-live="assertive"
    >
      <span class="text-white font-bold"
        >ðŸŽ‰ LEVEL UP! Level <span id="new-level">1</span></span
      >
    </div>

    <!-- Continue button -->
    <div class="mt-6 flex justify-center">
      <button
        id="challenge-continue"
        class="px-5 py-2 rounded-full bg-cyan-500 text-white font-semibold shadow-lg shadow-cyan-500/40 hover:bg-cyan-400 focus:outline-none focus-visible:ring-2 focus-visible:ring-cyan-300 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-900 transition"
        type="button"
      >
        Continue
      </button>
    </div>

    <!-- Dismiss hint -->
    <p class="text-gray-500 text-sm mt-3">
      Click outside or press Esc to continue
    </p>
  </div>
</template>

<style>
  @keyframes bounce-in {
    0% {
      transform: scale(0.5);
      opacity: 0;
    }
    50% {
      transform: scale(1.05);
    }
    100% {
      transform: scale(1);
      opacity: 1;
    }
  }

  .animate-bounce-in {
    animation: bounce-in 0.4s ease-out forwards;
  }
</style>

<script>
  /**
   * @typedef {Object} ChallengeCompleteData
   * @property {Array<{id:string,name:string,description:string,icon:string,xpReward:number}>} completedChallenges
   * @property {number} xpEarned
   * @property {boolean} levelUp
   * @property {number | undefined} [newLevel]
   */

  /** @type {ChallengeCompleteData[]} */
  const pendingCalls = []

  function ChallengeCompleteManager() {
    /** @type {HTMLElement|null} */
    this.overlay = document.getElementById('challenge-complete-overlay')
    /** @type {HTMLElement|null} */
    this.card = document.getElementById('challenge-complete-card')
    /** @type {HTMLTemplateElement|null} */
    this.template = document.getElementById('challenge-card-template')
    /** @type {ChallengeCompleteData[]} */
    this.queue = []
    this.isShowing = false
    /** @type {HTMLElement|null} */
    this.previouslyFocused = null
    /** @type {number|null} */
    this.autoDismissTimer = null
    /** @type {(() => void)|undefined} */
    this.resolveDismiss = undefined
    this.keydownHandler = event => this.handleKeydown(event)

    if (this.overlay) {
      this.overlay.addEventListener('click', event => {
        const target = /** @type {HTMLElement} */ (event.target)
        const isBackdrop =
          target === this.overlay ||
          (target &&
            target.dataset &&
            target.dataset.overlayBackdrop === 'true')
        if (isBackdrop) {
          this.dismiss()
        }
      })
    }
  }

  ChallengeCompleteManager.prototype.show = function (data) {
    this.queue.push(data)
    if (!this.isShowing) {
      this.processQueue()
    }
  }

  ChallengeCompleteManager.prototype.processQueue = async function () {
    if (this.queue.length === 0) {
      this.isShowing = false
      return
    }

    const data = this.queue[0]

    if (!data.completedChallenges.length) {
      this.isShowing = false
      this.queue.shift()
      this.processQueue()
      return
    }

    this.isShowing = true

    for (let i = 0; i < data.completedChallenges.length; i++) {
      const challenge = data.completedChallenges[i]
      const isLast = i === data.completedChallenges.length - 1
      this.renderCard(
        challenge,
        challenge.xpReward,
        isLast ? data.levelUp : false,
        isLast ? data.newLevel : undefined
      )
      this.showOverlay()
      this.startAutoDismiss()
      await new Promise(resolve => {
        this.resolveDismiss = resolve
      })
    }

    this.isShowing = false
    this.queue.shift()
    this.processQueue()
  }

  ChallengeCompleteManager.prototype.renderCard = function (
    challenge,
    xpEarned,
    levelUp,
    newLevel
  ) {
    if (!this.template || !this.card) {
      return
    }
    const content = this.template.content.cloneNode(true)

    const iconEl = content.getElementById('challenge-icon')
    const xpEl = content.getElementById('xp-earned')
    const nameEl = content.getElementById('challenge-name')
    const descEl = content.getElementById('challenge-description')
    if (iconEl) {
      iconEl.textContent = challenge.icon
    }
    if (xpEl) {
      xpEl.textContent = `+${xpEarned} XP`
    }
    if (nameEl) {
      nameEl.textContent = challenge.name
    }
    if (descEl) {
      descEl.textContent = challenge.description
    }

    if (levelUp && newLevel !== undefined && newLevel !== null) {
      const badge = content.getElementById('level-up-badge')
      const newLevelEl = content.getElementById('new-level')
      if (badge) {
        badge.classList.remove('hidden')
      }
      if (newLevelEl) {
        newLevelEl.textContent = String(newLevel)
      }
    }

    this.card.innerHTML = ''
    this.card.appendChild(content)

    const continueButton = this.card.querySelector('#challenge-continue')
    if (continueButton) {
      continueButton.addEventListener('click', () => this.dismiss())
    }
  }

  ChallengeCompleteManager.prototype.showOverlay = function () {
    if (!this.overlay) {
      return
    }
    this.previouslyFocused = document.activeElement
    this.overlay.classList.remove('hidden')
    this.overlay.setAttribute('aria-hidden', 'false')
    document.addEventListener('keydown', this.keydownHandler)
    this.setInitialFocus()
  }

  ChallengeCompleteManager.prototype.dismiss = function () {
    if (!this.overlay) {
      return
    }
    this.clearAutoDismiss()
    this.overlay.classList.add('hidden')
    this.overlay.setAttribute('aria-hidden', 'true')
    document.removeEventListener('keydown', this.keydownHandler)
    this.restoreFocus()
    const resolver = this.resolveDismiss
    this.resolveDismiss = undefined
    if (resolver) {
      resolver()
    }
  }

  ChallengeCompleteManager.prototype.setInitialFocus = function () {
    requestAnimationFrame(() => {
      const continueButton = this.card?.querySelector('#challenge-continue')
      const target = continueButton || this.card
      if (target && typeof target.focus === 'function') {
        target.focus()
      }
    })
  }

  ChallengeCompleteManager.prototype.getFocusableElements = function () {
    if (!this.card) {
      return []
    }
    const selectors =
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    return Array.from(this.card.querySelectorAll(selectors)).filter(el => {
      return (
        el &&
        !el.hasAttribute('disabled') &&
        el.getAttribute('aria-hidden') !== 'true' &&
        el.offsetParent !== null
      )
    })
  }

  ChallengeCompleteManager.prototype.handleKeydown = function (event) {
    if (!this.isShowing) {
      return
    }
    if (event.key === 'Escape') {
      event.preventDefault()
      this.dismiss()
      return
    }

    if (event.key !== 'Tab') {
      return
    }

    const focusable = this.getFocusableElements()
    if (focusable.length === 0) {
      event.preventDefault()
      this.card?.focus()
      return
    }

    const first = focusable[0]
    const last = focusable[focusable.length - 1]
    const active = document.activeElement

    if (event.shiftKey) {
      if (active === first || !this.card?.contains(active)) {
        event.preventDefault()
        if (last) {
          last.focus()
        }
      }
    } else if (active === last || !this.card?.contains(active)) {
      event.preventDefault()
      if (first) {
        first.focus()
      }
    }
  }

  ChallengeCompleteManager.prototype.restoreFocus = function () {
    if (
      this.previouslyFocused &&
      document.contains(this.previouslyFocused) &&
      typeof this.previouslyFocused.focus === 'function'
    ) {
      this.previouslyFocused.focus()
    }
    this.previouslyFocused = null
  }

  ChallengeCompleteManager.prototype.startAutoDismiss = function () {
    this.clearAutoDismiss()
    this.autoDismissTimer = window.setTimeout(() => this.dismiss(), 5000)
  }

  ChallengeCompleteManager.prototype.clearAutoDismiss = function () {
    if (this.autoDismissTimer !== null) {
      window.clearTimeout(this.autoDismissTimer)
      this.autoDismissTimer = null
    }
  }

  // Initialize and expose globally
  let manager = null

  document.addEventListener('DOMContentLoaded', () => {
    manager = new ChallengeCompleteManager()
    while (pendingCalls.length > 0) {
      const next = pendingCalls.shift()
      if (next) {
        manager.show(next)
      }
    }
  })

  window.showChallengeComplete = data => {
    if (manager) {
      manager.show(data)
      return
    }
    pendingCalls.push(data)
  }
</script>
