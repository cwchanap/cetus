---
import '@/styles/global.css'
import Button from '@/components/ui/Button.astro'
import Card from '@/components/ui/Card.astro'
import Badge from '@/components/ui/Badge.astro'
---

<html lang="en" class="dark">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />
    <title>Tetris Challenge - Cetus Minigames</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
  </head>

  <body
    class="min-h-screen bg-sci-fi-dark text-white overflow-x-hidden font-inter"
  >
    <!-- Animated background -->
    <div class="fixed inset-0 pointer-events-none">
      <div
        class="absolute inset-0 bg-gradient-radial from-cyan-400/20 via-transparent to-transparent animate-pulse"
      >
      </div>
      <div
        class="absolute inset-0 bg-gradient-radial from-purple-400/20 via-transparent to-transparent animate-pulse"
        style="animation-delay: 1s;"
      >
      </div>
    </div>

    <!-- Header -->
    <header class="relative z-10 px-6 py-4 border-b border-slate-700/50">
      <nav class="max-w-7xl mx-auto flex items-center justify-between">
        <div class="flex items-center space-x-3">
          <a href="/" class="flex items-center space-x-3">
            <div
              class="w-8 h-8 bg-gradient-to-r from-cyan-400 to-purple-500 rounded-lg flex items-center justify-center shadow-lg shadow-cyan-400/25"
            >
              <span class="text-lg font-bold text-white">C</span>
            </div>
            <h1 class="text-xl font-orbitron font-bold text-holographic">
              CETUS
            </h1>
          </a>
          <div class="text-cyan-400 text-sm">/ Tetris Challenge</div>
        </div>
        <div class="flex items-center space-x-4">
          <Button variant="outline" size="sm">
            <a href="/" class="text-white no-underline flex items-center">
              <span class="mr-2">üè†</span>
              Back to Menu
            </a>
          </Button>
        </div>
      </nav>
    </header>

    <main class="relative z-10 px-6 py-8">
      <div class="max-w-6xl mx-auto">
        <!-- Game Title -->
        <div class="text-center mb-8">
          <h2 class="text-5xl font-orbitron font-bold text-holographic mb-4">
            TETRIS CHALLENGE
          </h2>
          <p class="text-gray-400 text-lg">
            Stack the blocks and clear lines in this classic puzzle game
          </p>
        </div>

        <!-- Game Container -->
        <div class="flex flex-col lg:flex-row gap-8 items-start justify-center">
          <!-- Game Board -->
          <Card variant="glass" class="p-6 flex-shrink-0">
            <div class="flex flex-col items-center space-y-4">
              <!-- Game Status -->
              <div class="flex space-x-4 mb-4">
                <Badge variant="outline" class="px-4 py-2">
                  <span class="font-mono">Score: <span id="score">0</span></span
                  >
                </Badge>
                <Badge variant="outline" class="px-4 py-2">
                  <span class="font-mono">Level: <span id="level">1</span></span
                  >
                </Badge>
                <Badge variant="outline" class="px-4 py-2">
                  <span class="font-mono">Lines: <span id="lines">0</span></span
                  >
                </Badge>
              </div>

              <!-- Tetris Canvas -->
              <div class="relative">
                <canvas
                  id="tetris-canvas"
                  width="300"
                  height="600"
                  class="border-2 border-cyan-400/50 bg-black/50 rounded-lg shadow-glow-cyan"
                ></canvas>

                <!-- Game Over Overlay -->
                <div
                  id="game-over-overlay"
                  class="absolute inset-0 bg-black/80 rounded-lg flex items-center justify-center hidden"
                >
                  <div class="text-center">
                    <h3
                      class="text-3xl font-orbitron font-bold text-red-400 mb-4"
                    >
                      GAME OVER
                    </h3>
                    <p class="text-gray-400 mb-4">
                      Final Score: <span id="final-score" class="text-cyan-400"
                        >0</span
                      >
                    </p>
                    <Button id="restart-btn" variant="primary"
                      >Play Again</Button
                    >
                  </div>
                </div>
              </div>

              <!-- Game Controls -->
              <div class="flex space-x-2">
                <Button id="start-btn" variant="primary" size="sm">Start</Button
                >
                <Button id="pause-btn" variant="outline" size="sm">Pause</Button
                >
                <Button id="reset-btn" variant="outline" size="sm">Reset</Button
                >
              </div>
            </div>
          </Card>

          <!-- Next Piece & Controls -->
          <div class="flex flex-col space-y-6">
            <!-- Next Piece -->
            <Card variant="glass" class="p-6">
              <h3
                class="text-lg font-orbitron font-bold text-cyan-400 mb-4 text-center"
              >
                NEXT PIECE
              </h3>
              <canvas
                id="next-canvas"
                width="120"
                height="120"
                class="border border-cyan-400/30 bg-black/30 rounded-lg mx-auto block"
              ></canvas>
            </Card>

            <!-- Controls Guide -->
            <Card variant="glass" class="p-6">
              <h3 class="text-lg font-orbitron font-bold text-cyan-400 mb-4">
                CONTROLS
              </h3>
              <div class="space-y-2 text-sm">
                <div class="flex justify-between">
                  <span class="text-gray-400">Move Left:</span>
                  <Badge variant="outline" class="px-2 py-1 text-xs">‚Üê</Badge>
                </div>
                <div class="flex justify-between">
                  <span class="text-gray-400">Move Right:</span>
                  <Badge variant="outline" class="px-2 py-1 text-xs">‚Üí</Badge>
                </div>
                <div class="flex justify-between">
                  <span class="text-gray-400">Soft Drop:</span>
                  <Badge variant="outline" class="px-2 py-1 text-xs">‚Üì</Badge>
                </div>
                <div class="flex justify-between">
                  <span class="text-gray-400">Hard Drop:</span>
                  <Badge variant="outline" class="px-2 py-1 text-xs"
                    >Space</Badge
                  >
                </div>
                <div class="flex justify-between">
                  <span class="text-gray-400">Rotate:</span>
                  <Badge variant="outline" class="px-2 py-1 text-xs">‚Üë</Badge>
                </div>
                <div class="flex justify-between">
                  <span class="text-gray-400">Pause:</span>
                  <Badge variant="outline" class="px-2 py-1 text-xs">P</Badge>
                </div>
              </div>
            </Card>

            <!-- Statistics -->
            <Card variant="glass" class="p-6">
              <h3 class="text-lg font-orbitron font-bold text-cyan-400 mb-4">
                STATISTICS
              </h3>
              <div class="space-y-2 text-sm">
                <div class="flex justify-between">
                  <span class="text-gray-400">Pieces:</span>
                  <span id="pieces-count" class="text-white">0</span>
                </div>
                <div class="flex justify-between">
                  <span class="text-gray-400">Singles:</span>
                  <span id="singles-count" class="text-white">0</span>
                </div>
                <div class="flex justify-between">
                  <span class="text-gray-400">Doubles:</span>
                  <span id="doubles-count" class="text-white">0</span>
                </div>
                <div class="flex justify-between">
                  <span class="text-gray-400">Triples:</span>
                  <span id="triples-count" class="text-white">0</span>
                </div>
                <div class="flex justify-between">
                  <span class="text-gray-400">Tetrises:</span>
                  <span id="tetrises-count" class="text-cyan-400">0</span>
                </div>
              </div>
            </Card>
          </div>
        </div>
      </div>
    </main>

    <!-- Tetris Game Logic -->
    <script is:inline>
      class TetrisGame {
        constructor() {
          this.canvas = document.getElementById('tetris-canvas')
          this.ctx = this.canvas.getContext('2d')
          this.nextCanvas = document.getElementById('next-canvas')
          this.nextCtx = this.nextCanvas.getContext('2d')

          // Game constants
          this.BOARD_WIDTH = 10
          this.BOARD_HEIGHT = 20
          this.BLOCK_SIZE = 30

          // Game state
          this.board = Array(this.BOARD_HEIGHT)
            .fill()
            .map(() => Array(this.BOARD_WIDTH).fill(0))
          this.currentPiece = null
          this.nextPiece = null
          this.score = 0
          this.level = 1
          this.lines = 0
          this.gameOver = false
          this.paused = false
          this.gameStarted = false

          // Statistics
          this.stats = {
            pieces: 0,
            singles: 0,
            doubles: 0,
            triples: 0,
            tetrises: 0,
          }

          // Timing
          this.dropTime = 0
          this.dropInterval = 1000 // 1 second

          // Tetris pieces (Tetrominoes)
          this.pieces = {
            I: {
              shape: [[1, 1, 1, 1]],
              color: '#00ffff',
            },
            O: {
              shape: [
                [1, 1],
                [1, 1],
              ],
              color: '#ffff00',
            },
            T: {
              shape: [
                [0, 1, 0],
                [1, 1, 1],
              ],
              color: '#800080',
            },
            S: {
              shape: [
                [0, 1, 1],
                [1, 1, 0],
              ],
              color: '#00ff00',
            },
            Z: {
              shape: [
                [1, 1, 0],
                [0, 1, 1],
              ],
              color: '#ff0000',
            },
            J: {
              shape: [
                [1, 0, 0],
                [1, 1, 1],
              ],
              color: '#0000ff',
            },
            L: {
              shape: [
                [0, 0, 1],
                [1, 1, 1],
              ],
              color: '#ffa500',
            },
          }

          this.pieceTypes = Object.keys(this.pieces)

          this.init()
        }

        init() {
          this.setupEventListeners()
          this.generateNextPiece()
          this.draw()
        }

        setupEventListeners() {
          // Button controls
          document
            .getElementById('start-btn')
            .addEventListener('click', () => this.startGame())
          document
            .getElementById('pause-btn')
            .addEventListener('click', () => this.togglePause())
          document
            .getElementById('reset-btn')
            .addEventListener('click', () => this.resetGame())
          document
            .getElementById('restart-btn')
            .addEventListener('click', () => this.resetGame())

          // Page unload warning
          window.addEventListener('beforeunload', e => {
            if (this.gameStarted && !this.gameOver && !this.paused) {
              e.preventDefault()
              e.returnValue = '' // Required for Chrome
              return 'You have a game in progress. Are you sure you want to leave?'
            }
          })

          // Keyboard controls
          document.addEventListener('keydown', e => {
            if (!this.gameStarted || this.gameOver || this.paused) {
              return
            }

            switch (e.key) {
              case 'ArrowLeft':
                e.preventDefault()
                this.movePiece(-1, 0)
                break
              case 'ArrowRight':
                e.preventDefault()
                this.movePiece(1, 0)
                break
              case 'ArrowDown':
                e.preventDefault()
                this.movePiece(0, 1)
                break
              case 'ArrowUp':
                e.preventDefault()
                this.rotatePiece()
                break
              case ' ':
                e.preventDefault()
                this.hardDrop()
                break
              case 'p':
              case 'P':
                e.preventDefault()
                this.togglePause()
                break
            }
          })
        }

        startGame() {
          if (!this.gameStarted) {
            this.gameStarted = true
            this.spawnPiece()
            this.gameLoop()
            document.getElementById('start-btn').textContent = 'Playing...'
            document.getElementById('start-btn').disabled = true
          }
        }

        togglePause() {
          if (!this.gameStarted || this.gameOver) {
            return
          }

          this.paused = !this.paused
          const pauseBtn = document.getElementById('pause-btn')
          pauseBtn.textContent = this.paused ? 'Resume' : 'Pause'

          if (!this.paused) {
            this.gameLoop()
          }
        }

        resetGame() {
          this.board = Array(this.BOARD_HEIGHT)
            .fill()
            .map(() => Array(this.BOARD_WIDTH).fill(0))
          this.currentPiece = null
          this.score = 0
          this.level = 1
          this.lines = 0
          this.gameOver = false
          this.paused = false
          this.gameStarted = false
          this.stats = {
            pieces: 0,
            singles: 0,
            doubles: 0,
            triples: 0,
            tetrises: 0,
          }

          this.generateNextPiece()
          this.updateUI()
          this.draw()

          document.getElementById('game-over-overlay').classList.add('hidden')
          document.getElementById('start-btn').textContent = 'Start'
          document.getElementById('start-btn').disabled = false
          document.getElementById('pause-btn').textContent = 'Pause'
        }

        generateNextPiece() {
          const randomType =
            this.pieceTypes[Math.floor(Math.random() * this.pieceTypes.length)]
          this.nextPiece = {
            type: randomType,
            shape: JSON.parse(JSON.stringify(this.pieces[randomType].shape)),
            color: this.pieces[randomType].color,
            x: 0,
            y: 0,
          }
          this.drawNext()
        }

        spawnPiece() {
          this.currentPiece = this.nextPiece
          this.currentPiece.x = Math.floor(
            (this.BOARD_WIDTH - this.currentPiece.shape[0].length) / 2
          )
          this.currentPiece.y = 0

          this.generateNextPiece()
          this.stats.pieces++

          // Check for game over
          if (
            this.checkCollision(
              this.currentPiece.x,
              this.currentPiece.y,
              this.currentPiece.shape
            )
          ) {
            this.endGame()
          }
        }

        movePiece(dx, dy) {
          if (!this.currentPiece) {
            return
          }

          const newX = this.currentPiece.x + dx
          const newY = this.currentPiece.y + dy

          if (!this.checkCollision(newX, newY, this.currentPiece.shape)) {
            this.currentPiece.x = newX
            this.currentPiece.y = newY
            this.draw()
          } else if (dy > 0) {
            // Piece hit bottom or another piece
            this.placePiece()
          }
        }

        rotatePiece() {
          if (!this.currentPiece) {
            return
          }

          const rotated = this.rotateMatrix(this.currentPiece.shape)

          if (
            !this.checkCollision(
              this.currentPiece.x,
              this.currentPiece.y,
              rotated
            )
          ) {
            this.currentPiece.shape = rotated
            this.draw()
          }
        }

        hardDrop() {
          if (!this.currentPiece) {
            return
          }

          while (
            !this.checkCollision(
              this.currentPiece.x,
              this.currentPiece.y + 1,
              this.currentPiece.shape
            )
          ) {
            this.currentPiece.y++
            this.score += 2 // Bonus points for hard drop
          }
          this.placePiece()
        }

        rotateMatrix(matrix) {
          const rows = matrix.length
          const cols = matrix[0].length
          const rotated = Array(cols)
            .fill()
            .map(() => Array(rows).fill(0))

          for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
              rotated[j][rows - 1 - i] = matrix[i][j]
            }
          }

          return rotated
        }

        checkCollision(x, y, shape) {
          for (let row = 0; row < shape.length; row++) {
            for (let col = 0; col < shape[row].length; col++) {
              if (shape[row][col]) {
                const newX = x + col
                const newY = y + row

                // Check boundaries
                if (
                  newX < 0 ||
                  newX >= this.BOARD_WIDTH ||
                  newY >= this.BOARD_HEIGHT
                ) {
                  return true
                }

                // Check collision with placed pieces
                if (newY >= 0 && this.board[newY][newX]) {
                  return true
                }
              }
            }
          }
          return false
        }

        placePiece() {
          if (!this.currentPiece) {
            return
          }

          // Place piece on board
          for (let row = 0; row < this.currentPiece.shape.length; row++) {
            for (
              let col = 0;
              col < this.currentPiece.shape[row].length;
              col++
            ) {
              if (this.currentPiece.shape[row][col]) {
                const y = this.currentPiece.y + row
                const x = this.currentPiece.x + col
                if (y >= 0) {
                  this.board[y][x] = this.currentPiece.color
                }
              }
            }
          }

          // Check for completed lines
          this.clearLines()

          // Spawn next piece
          this.spawnPiece()
          this.draw()
        }

        clearLines() {
          let linesCleared = 0

          for (let row = this.BOARD_HEIGHT - 1; row >= 0; row--) {
            if (this.board[row].every(cell => cell !== 0)) {
              this.board.splice(row, 1)
              this.board.unshift(Array(this.BOARD_WIDTH).fill(0))
              linesCleared++
              row++ // Check same row again
            }
          }

          if (linesCleared > 0) {
            this.lines += linesCleared
            this.updateLevel()
            this.updateScore(linesCleared)
            this.updateStats(linesCleared)
          }
        }

        updateScore(linesCleared) {
          const baseScore = [0, 40, 100, 300, 1200][linesCleared]
          this.score += baseScore * this.level
        }

        updateStats(linesCleared) {
          switch (linesCleared) {
            case 1:
              this.stats.singles++
              break
            case 2:
              this.stats.doubles++
              break
            case 3:
              this.stats.triples++
              break
            case 4:
              this.stats.tetrises++
              break
          }
        }

        updateLevel() {
          const newLevel = Math.floor(this.lines / 10) + 1
          if (newLevel > this.level) {
            this.level = newLevel
            this.dropInterval = Math.max(50, 1000 - (this.level - 1) * 50)
          }
        }

        endGame() {
          this.gameOver = true
          this.gameStarted = false
          document.getElementById('final-score').textContent = this.score
          document
            .getElementById('game-over-overlay')
            .classList.remove('hidden')
        }

        gameLoop() {
          if (this.gameOver || this.paused || !this.gameStarted) {
            return
          }

          const now = Date.now()
          if (now - this.dropTime > this.dropInterval) {
            this.movePiece(0, 1)
            this.dropTime = now
          }

          this.updateUI()
          requestAnimationFrame(() => this.gameLoop())
        }

        updateUI() {
          document.getElementById('score').textContent = this.score
          document.getElementById('level').textContent = this.level
          document.getElementById('lines').textContent = this.lines
          document.getElementById('pieces-count').textContent =
            this.stats.pieces
          document.getElementById('singles-count').textContent =
            this.stats.singles
          document.getElementById('doubles-count').textContent =
            this.stats.doubles
          document.getElementById('triples-count').textContent =
            this.stats.triples
          document.getElementById('tetrises-count').textContent =
            this.stats.tetrises
        }

        draw() {
          // Clear canvas
          this.ctx.fillStyle = '#000'
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)

          // Draw board
          this.drawBoard()

          // Draw current piece
          if (this.currentPiece) {
            this.drawPiece(this.currentPiece, this.ctx)
          }

          // Draw grid
          this.drawGrid()
        }

        drawBoard() {
          for (let row = 0; row < this.BOARD_HEIGHT; row++) {
            for (let col = 0; col < this.BOARD_WIDTH; col++) {
              if (this.board[row][col]) {
                this.ctx.fillStyle = this.board[row][col]
                this.ctx.fillRect(
                  col * this.BLOCK_SIZE,
                  row * this.BLOCK_SIZE,
                  this.BLOCK_SIZE,
                  this.BLOCK_SIZE
                )

                // Add border
                this.ctx.strokeStyle = '#fff'
                this.ctx.lineWidth = 1
                this.ctx.strokeRect(
                  col * this.BLOCK_SIZE,
                  row * this.BLOCK_SIZE,
                  this.BLOCK_SIZE,
                  this.BLOCK_SIZE
                )
              }
            }
          }
        }

        drawPiece(piece, ctx) {
          ctx.fillStyle = piece.color

          for (let row = 0; row < piece.shape.length; row++) {
            for (let col = 0; col < piece.shape[row].length; col++) {
              if (piece.shape[row][col]) {
                const x = (piece.x + col) * this.BLOCK_SIZE
                const y = (piece.y + row) * this.BLOCK_SIZE

                ctx.fillRect(x, y, this.BLOCK_SIZE, this.BLOCK_SIZE)

                // Add border
                ctx.strokeStyle = '#fff'
                ctx.lineWidth = 1
                ctx.strokeRect(x, y, this.BLOCK_SIZE, this.BLOCK_SIZE)
              }
            }
          }
        }

        drawGrid() {
          this.ctx.strokeStyle = '#333'
          this.ctx.lineWidth = 1

          // Vertical lines
          for (let x = 0; x <= this.BOARD_WIDTH; x++) {
            this.ctx.beginPath()
            this.ctx.moveTo(x * this.BLOCK_SIZE, 0)
            this.ctx.lineTo(x * this.BLOCK_SIZE, this.canvas.height)
            this.ctx.stroke()
          }

          // Horizontal lines
          for (let y = 0; y <= this.BOARD_HEIGHT; y++) {
            this.ctx.beginPath()
            this.ctx.moveTo(0, y * this.BLOCK_SIZE)
            this.ctx.lineTo(this.canvas.width, y * this.BLOCK_SIZE)
            this.ctx.stroke()
          }
        }

        drawNext() {
          if (!this.nextPiece) {
            return
          }

          // Clear next canvas
          this.nextCtx.fillStyle = '#000'
          this.nextCtx.fillRect(
            0,
            0,
            this.nextCanvas.width,
            this.nextCanvas.height
          )

          // Calculate center position
          const pieceWidth = this.nextPiece.shape[0].length * 20
          const pieceHeight = this.nextPiece.shape.length * 20
          const offsetX = (this.nextCanvas.width - pieceWidth) / 2
          const offsetY = (this.nextCanvas.height - pieceHeight) / 2

          // Draw next piece
          this.nextCtx.fillStyle = this.nextPiece.color

          for (let row = 0; row < this.nextPiece.shape.length; row++) {
            for (let col = 0; col < this.nextPiece.shape[row].length; col++) {
              if (this.nextPiece.shape[row][col]) {
                const x = offsetX + col * 20
                const y = offsetY + row * 20

                this.nextCtx.fillRect(x, y, 20, 20)

                // Add border
                this.nextCtx.strokeStyle = '#fff'
                this.nextCtx.lineWidth = 1
                this.nextCtx.strokeRect(x, y, 20, 20)
              }
            }
          }
        }
      }

      // Initialize game when page loads
      document.addEventListener('DOMContentLoaded', () => {
        new TetrisGame()
      })
    </script>
  </body>
</html>
