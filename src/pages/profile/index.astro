---
import AppLayout from '@/layouts/AppLayout.astro'

// Component Imports
import Container from '@/components/ui/Container.astro'
import Section from '@/components/ui/Section.astro'
import Heading from '@/components/ui/Heading.astro'
import Card from '@/components/ui/Card.astro'
import Badge from '@/components/ui/Badge.astro'
import Button from '@/components/ui/Button.astro'

import { getUserStats, getUserDailyActivity } from '@/lib/server/db/queries'

// Check if user is authenticated
const user = Astro.locals.user
const session = Astro.locals.session

// Redirect to login if not authenticated
if (!user) {
  return Astro.redirect('/login?redirect=/profile')
}

// Fetch user stats
const userStats = await getUserStats(user.id)

// Build contribution data for current year (UTC)
const now = new Date()
const year = now.getUTCFullYear()
const rawDaily = await getUserDailyActivity(user.id, year)
const dailyMap = new Map(rawDaily.map(d => [d.date, d.count]))

const firstDay = new Date(Date.UTC(year, 0, 1))
const lastDay = new Date(Date.UTC(year + 1, 0, 0)) // Dec 31

// Start from Sunday on or before Jan 1
const calendarStart = new Date(firstDay)
calendarStart.setUTCDate(firstDay.getUTCDate() - firstDay.getUTCDay())

// End on Saturday on or after Dec 31
const calendarEnd = new Date(lastDay)
calendarEnd.setUTCDate(lastDay.getUTCDate() + (6 - lastDay.getUTCDay()))

type DayCell = { date: Date; dateStr: string; count: number; month: number }
const weeks: DayCell[][] = []
const d = new Date(calendarStart)
let maxCount = 0
while (d <= calendarEnd) {
  const week: DayCell[] = []
  for (let i = 0; i < 7; i++) {
    const y = d.getUTCFullYear()
    const m = d.getUTCMonth()
    const day = d.getUTCDate()
    const dateStr = `${y}-${String(m + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`
    const inYear = d >= firstDay && d <= lastDay
    const count = inYear ? (dailyMap.get(dateStr) ?? 0) : -1 // -1 = padding cell
    if (count > maxCount) {
      maxCount = count
    }
    week.push({ date: new Date(d), dateStr, count, month: m })
    d.setUTCDate(d.getUTCDate() + 1)
  }
  weeks.push(week)
}

// Precompute month label per week using first in-year day to avoid showing previous year's Dec before Jan
const weekLabelMonth: number[] = weeks.map(week => {
  const inYearCell =
    week.find(c => c.date >= firstDay && c.date <= lastDay) ?? week[0]
  return inYearCell.month
})
const showMonthFlags: boolean[] = weekLabelMonth.map(
  (m, i) => i === 0 || weekLabelMonth[i - 1] !== m
)

function intensityLevel(count: number): 0 | 1 | 2 | 3 | 4 {
  if (count <= 0) {
    return 0
  }
  if (count <= 1) {
    return 1
  }
  if (count <= 3) {
    return 2
  }
  if (count <= 6) {
    return 3
  }
  return 4
}

const monthShort = [
  'Jan',
  'Feb',
  'Mar',
  'Apr',
  'May',
  'Jun',
  'Jul',
  'Aug',
  'Sep',
  'Oct',
  'Nov',
  'Dec',
]

// Get user display name
const userName = user.name || user.email?.split('@')[0] || 'Anonymous User'
const userEmail = user.email || 'No email provided'

// Get user's registration date from session or use a default
const memberSince = session?.createdAt
  ? new Date(session.createdAt).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    })
  : 'Recently'
---

<AppLayout
  title="Profile - Cetus Gaming Platform"
  description="View your gaming profile, statistics, and game history on Cetus"
>
  <!-- Cropper.js CSS -->
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css"
  />
  <!-- Custom cropper styles -->
  <style>
    /* Ensure cropper fills the container properly */
    #crop-container {
      position: relative;
    }

    #crop-container .cropper-container {
      width: 100% !important;
      height: 100% !important;
    }

    /* Make the canvas fill as much space as possible */
    #crop-container .cropper-canvas {
      max-width: none !important;
      max-height: none !important;
    }

    /* Ensure crop box has reasonable minimum size */
    #crop-container .cropper-crop-box {
      min-width: 100px !important;
      min-height: 100px !important;
    }

    /* Ensure the image can scale to fill available space */
    #crop-container .cropper-canvas img {
      max-width: none !important;
      max-height: none !important;
    }

    /* Make modal background more subtle */
    #crop-container .cropper-modal {
      background-color: rgba(0, 0, 0, 0.6) !important;
    }

    /* Style the drag area */
    #crop-container .cropper-drag-box {
      background-color: rgba(255, 255, 255, 0.1) !important;
    }
  </style>
  <!-- Animated background -->
  <div class="fixed inset-0 pointer-events-none">
    <div
      class="absolute inset-0 bg-gradient-radial from-cyan-400/20 via-transparent to-transparent animate-pulse"
    >
    </div>
    <div
      class="absolute inset-0 bg-gradient-radial from-purple-400/20 via-transparent to-transparent animate-pulse"
      style="animation-delay: 1s;"
    >
    </div>
    <div
      class="absolute inset-0 bg-gradient-radial from-pink-400/15 via-transparent to-transparent animate-pulse"
      style="animation-delay: 2s;"
    >
    </div>
  </div>

  <!-- Floating particles -->
  <div class="fixed inset-0 pointer-events-none">
    {
      Array.from({ length: 20 }).map((_, _i) => (
        <div
          class="absolute w-1 h-1 bg-cyan-400 rounded-full opacity-20 animate-bounce"
          style={`
              left: ${Math.random() * 100}%;
              top: ${Math.random() * 100}%;
              animation-delay: ${Math.random() * 3}s;
              animation-duration: ${2 + Math.random() * 2}s;
            `}
        />
      ))
    }
  </div>

  <!-- Profile Content -->
  <main class="relative z-10 min-h-screen">
    <Section class="py-20">
      <Container class="max-w-4xl">
        <!-- Page Title -->
        <div class="text-center mb-12">
          <Heading level={1} variant="hero" align="center" class="mb-4">
            USER PROFILE
          </Heading>
          <p class="text-gray-400 text-lg">
            Manage your account and track your achievements
          </p>
        </div>

        <!-- User Info Card -->
        <Card variant="glass" class="p-6 md:p-8 mb-8">
          <div class="flex flex-row items-start">
            <!-- Avatar -->
            <div class="flex-shrink-0 mr-2.5">
              <div class="relative group">
                <div
                  id="avatar-display"
                  class="w-20 h-20 bg-gradient-to-r from-cyan-400 to-purple-500 rounded-full flex items-center justify-center shadow-lg shadow-cyan-400/25 overflow-hidden"
                >
                  {
                    user.image ? (
                      <img
                        src={user.image}
                        alt="User avatar"
                        class="w-full h-full object-cover"
                        id="current-avatar"
                      />
                    ) : (
                      <span
                        class="text-2xl font-bold text-white"
                        id="avatar-initial"
                      >
                        {userName.charAt(0).toUpperCase()}
                      </span>
                    )
                  }
                </div>
                <!-- Avatar upload overlay -->
                <div
                  class="absolute inset-0 bg-black/50 rounded-full flex flex-col items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity cursor-pointer"
                  id="avatar-upload-overlay"
                >
                  <span class="text-white text-xs font-medium mb-1"
                    >üì∑ Upload</span
                  >
                  {
                    user.image && (
                      <button
                        id="remove-avatar-btn"
                        class="text-red-400 text-xs font-medium hover:text-red-300 transition-colors"
                        type="button"
                      >
                        üóëÔ∏è Remove
                      </button>
                    )
                  }
                </div>
                <!-- Hidden file input -->
                <input
                  type="file"
                  id="avatar-input"
                  accept="image/*"
                  class="hidden"
                />
              </div>
            </div>

            <!-- User Details -->
            <div class="flex-1 min-w-0 text-left">
              <div class="flex items-center gap-3 mb-2">
                <div class="flex-1">
                  <!-- Name display/edit form -->
                  <div id="name-display" class="flex items-center gap-3">
                    <h2
                      class="text-2xl font-orbitron font-bold text-holographic"
                    >
                      {userName}
                    </h2>
                    <button
                      id="edit-name-btn"
                      class="text-cyan-400 hover:text-cyan-300 transition-colors"
                      title="Edit name"
                    >
                      ‚úèÔ∏è
                    </button>
                  </div>

                  <!-- Name edit form (hidden by default) -->
                  <div id="name-edit-form" class="hidden">
                    <form class="flex items-center gap-2">
                      <input
                        type="text"
                        id="name-input"
                        value={userName}
                        maxlength="100"
                        class="flex-1 px-3 py-2 bg-gray-800/50 border border-gray-600/50 rounded-lg text-white font-orbitron font-bold text-xl focus:outline-none focus:ring-2 focus:ring-cyan-400/50 focus:border-cyan-400/50"
                      />
                      <Button
                        variant="outline"
                        size="sm"
                        type="submit"
                        id="save-name-btn"
                      >
                        üíæ
                      </Button>
                      <button
                        type="button"
                        id="cancel-edit-btn"
                        class="px-2 py-1 text-gray-400 hover:text-gray-300 transition-colors"
                      >
                        ‚ùå
                      </button>
                    </form>
                  </div>
                </div>

                <Badge variant="success" size="sm"> Space Explorer üöÄ </Badge>
              </div>

              <p class="text-gray-300 mb-4">
                {userEmail}
              </p>

              <div
                class="flex flex-col sm:flex-row sm:items-center sm:space-x-4 text-sm text-gray-400 space-y-2 sm:space-y-0"
              >
                <div class="flex items-center justify-start space-x-1">
                  <span>üìÖ</span>
                  <span>Member since {memberSince}</span>
                </div>
                <div class="flex items-center justify-start space-x-1">
                  <span>üéÆ</span>
                  <span>Games Played: {userStats?.total_games_played || 0}</span
                  >
                </div>
              </div>
            </div>
          </div>
        </Card>

        <!-- Activity Graph -->
        <Card variant="glass" class="p-6 mb-8">
          <div class="flex items-center justify-between mb-4">
            <h3 class="text-lg font-orbitron font-bold text-cyan-400">
              Activity ¬∑ {year}
            </h3>
            <div
              class="hidden sm:flex items-center gap-2 text-xs text-gray-400"
            >
              <span>Less</span>
              <span class="w-[0.891rem] h-[0.891rem] rounded-sm bg-gray-800/60"
              ></span>
              <span class="w-[0.891rem] h-[0.891rem] rounded-sm bg-cyan-500/10"
              ></span>
              <span class="w-[0.891rem] h-[0.891rem] rounded-sm bg-cyan-500/30"
              ></span>
              <span class="w-[0.891rem] h-[0.891rem] rounded-sm bg-cyan-400/60"
              ></span>
              <span class="w-[0.891rem] h-[0.891rem] rounded-sm bg-cyan-300"
              ></span>
              <span>More</span>
            </div>
          </div>
          <div class="flex">
            <!-- Month Labels -->
            <div class="sticky left-0 text-xs text-gray-400 hidden md:block">
              <div class="h-[0.891rem]"></div>
              <div class="grid grid-rows-7 auto-rows-[0.891rem] gap-[2px]">
                <span class="h-[0.891rem]">Sun</span>
                <span class="h-[0.891rem]">Mon</span>
                <span class="h-[0.891rem]">Tue</span>
                <span class="h-[0.891rem]">Wed</span>
                <span class="h-[0.891rem]">Thu</span>
                <span class="h-[0.891rem]">Fri</span>
                <span class="h-[0.891rem]">Sat</span>
              </div>
            </div>

            <div class="overflow-x-auto" data-testid="activity-graph">
              <div class="flex items-start gap-[2px]">
                {
                  weeks.map((week, wi) => {
                    const labelMonth = weekLabelMonth[wi]
                    const showMonth = showMonthFlags[wi]
                    return (
                      <div
                        class="flex flex-col items-center w-[0.891rem] shrink-0"
                        title={showMonth ? monthShort[labelMonth] : ''}
                      >
                        <div class="h-[0.891rem] leading-[0.891rem] whitespace-nowrap overflow-visible text-[10px] text-gray-400">
                          {showMonth ? monthShort[labelMonth] : ''}
                        </div>
                        <div class="grid grid-rows-7 auto-rows-[0.891rem] gap-[2px]">
                          {week.map(day => {
                            const lvl =
                              day.count < 0 ? -1 : intensityLevel(day.count)
                            const cls =
                              lvl === -1
                                ? 'opacity-20 bg-transparent'
                                : lvl === 0
                                  ? 'bg-gray-800/60'
                                  : lvl === 1
                                    ? 'bg-cyan-500/10'
                                    : lvl === 2
                                      ? 'bg-cyan-500/30'
                                      : lvl === 3
                                        ? 'bg-cyan-400/60'
                                        : 'bg-cyan-300'

                            const tooltip =
                              day.count < 0
                                ? ''
                                : `${day.count} activit${day.count === 1 ? 'y' : 'ies'} on ${day.date.toUTCString().slice(0, 16)}`

                            return (
                              <div
                                data-testid="activity-cell"
                                class={`w-[0.891rem] h-[0.891rem] rounded-[3px] ${cls}`}
                                title={tooltip}
                              />
                            )
                          })}
                        </div>
                      </div>
                    )
                  })
                }
              </div>
            </div>
          </div>
        </Card>

        <!-- Quick Stats -->
        <Card variant="glass" class="p-6 mb-8">
          <h3 class="text-lg font-orbitron font-bold text-cyan-400 mb-4">
            Quick Stats
          </h3>
          <div class="grid grid-cols-2 md:grid-cols-4 gap-6">
            <div class="text-center">
              <div class="text-2xl font-bold text-white mb-1">
                {userStats?.total_score?.toLocaleString() || 0}
              </div>
              <div class="text-sm text-gray-400">Total Score</div>
            </div>
            <div class="text-center">
              <div class="text-2xl font-bold text-white mb-1">
                {userStats?.total_games_played || 0}
              </div>
              <div class="text-sm text-gray-400">Games Played</div>
            </div>
            <div class="text-center">
              <div class="text-2xl font-bold text-white mb-1">
                {
                  userStats
                    ? Math.round(
                        (userStats.total_score || 0) /
                          Math.max(1, userStats.total_games_played || 0)
                      )
                    : 0
                }
              </div>
              <div class="text-sm text-gray-400">Avg Score</div>
            </div>
            <div class="text-center">
              <div class="text-2xl font-bold text-white mb-1">
                {userStats?.streak_days || 0}
              </div>
              <div class="text-sm text-gray-400">Streak Days</div>
            </div>
          </div>
        </Card>

        <!-- Quick Actions -->
        <Card variant="glass" class="p-6 mb-8">
          <h3 class="text-lg font-orbitron font-bold text-cyan-400 mb-4">
            Quick Actions
          </h3>
          <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
            <Button variant="outline" size="lg" class="justify-center">
              <a
                href="/dashboard"
                class="text-cyan-400 no-underline flex items-center"
              >
                <span class="mr-2">üìä</span>
                View Dashboard
              </a>
            </Button>
            <Button variant="outline" size="lg" class="justify-center">
              <a
                href="/#games"
                class="text-cyan-400 no-underline flex items-center"
              >
                <span class="mr-2">üéÆ</span>
                Play Games
              </a>
            </Button>
          </div>
        </Card>
      </Container>
    </Section>
  </main>

  <script>
    // Add some interactive effects
    document.addEventListener('DOMContentLoaded', () => {
      // Add glow effect on achievement cards
      const achievementCards = document.querySelectorAll('[data-achievement]')
      achievementCards.forEach(card => {
        card.addEventListener('mouseenter', () => {
          if (!card.classList.contains('opacity-60')) {
            card.classList.add('glow-cyan')
          }
        })

        card.addEventListener('mouseleave', () => {
          card.classList.remove('glow-cyan')
        })
      })

      // Add floating animation to particles
      const particles = document.querySelectorAll('.animate-bounce')
      particles.forEach((particle, index) => {
        if (index % 3 === 0) {
          particle.classList.add('animate-float')
        }
      })

      // Name editing functionality
      const nameDisplay = document.getElementById('name-display')
      const nameEditForm = document.getElementById('name-edit-form')
      const editNameBtn = document.getElementById('edit-name-btn')
      const cancelEditBtn = document.getElementById('cancel-edit-btn')
      const nameInput = document.getElementById('name-input')
      const nameForm = nameEditForm?.querySelector('form')
      const nameHeading = nameDisplay?.querySelector('h2')

      // Enter edit mode
      editNameBtn?.addEventListener('click', () => {
        nameDisplay?.classList.add('hidden')
        nameEditForm?.classList.remove('hidden')
        nameInput?.focus()
      })

      // Cancel editing
      cancelEditBtn?.addEventListener('click', () => {
        nameEditForm?.classList.add('hidden')
        nameDisplay?.classList.remove('hidden')
        if (nameInput && nameHeading) {
          ;(nameInput as HTMLInputElement).value =
            nameHeading.textContent?.trim() || ''
        }
      })

      // Handle form submission
      nameForm?.addEventListener('submit', async e => {
        e.preventDefault()

        const newName = (nameInput as HTMLInputElement)?.value?.trim()
        if (!newName) {
          alert('Name cannot be empty')
          return
        }

        if (newName.length > 100) {
          alert('Name must be 100 characters or less')
          return
        }

        // Show loading state
        const saveBtn = document.getElementById('save-name-btn')
        const originalText = saveBtn?.textContent || 'üíæ'

        try {
          if (saveBtn) {
            saveBtn.textContent = '‚è≥'
          }

          const response = await fetch('/api/user/profile', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ name: newName }),
          })

          const result = await response.json()

          if (response.ok && result.success) {
            // Update the display
            if (nameHeading) {
              nameHeading.textContent = result.name
            }

            // Exit edit mode
            nameEditForm?.classList.add('hidden')
            nameDisplay?.classList.remove('hidden')

            // Show success message
            showMessage('Profile updated successfully!', 'success')
          } else {
            showMessage(result.error || 'Failed to update profile', 'error')
          }
        } catch (error) {
          console.error('Error updating profile:', error)
          showMessage('Network error. Please try again.', 'error')
        } finally {
          // Reset button
          if (saveBtn) {
            saveBtn.textContent = originalText
          }
        }
      })

      // Handle escape key to cancel editing
      nameInput?.addEventListener('keydown', e => {
        if (e.key === 'Escape') {
          cancelEditBtn?.click()
        }
      })
    })

    // Avatar upload functionality
    document.addEventListener('DOMContentLoaded', () => {
      const avatarUploadOverlay = document.getElementById(
        'avatar-upload-overlay'
      )
      const avatarInput = document.getElementById(
        'avatar-input'
      ) as HTMLInputElement
      const avatarDisplay = document.getElementById('avatar-display')
      const currentAvatar = document.getElementById(
        'current-avatar'
      ) as HTMLImageElement
      const avatarInitial = document.getElementById('avatar-initial')
      const removeAvatarBtn = document.getElementById('remove-avatar-btn')

      // Cropping modal elements
      const cropModal = document.getElementById('crop-modal')
      let cropImage = document.getElementById('crop-image') as HTMLImageElement
      const cropContainer = document.getElementById('crop-container')
      const cropCancelBtn = document.getElementById('crop-cancel-btn')
      const cropApplyBtn = document.getElementById('crop-apply-btn')

      let cropper: any = null

      // Click overlay to trigger file input (but not when clicking remove button)
      avatarUploadOverlay?.addEventListener('click', e => {
        if (
          e.target !== removeAvatarBtn &&
          !removeAvatarBtn?.contains(e.target as Node)
        ) {
          avatarInput?.click()
        }
      })

      // Handle avatar removal
      removeAvatarBtn?.addEventListener('click', async e => {
        e.stopPropagation()

        if (!confirm('Are you sure you want to remove your avatar?')) {
          return
        }

        try {
          const response = await fetch('/api/user/avatar', {
            method: 'DELETE',
          })

          const result = await response.json()

          if (response.ok && result.success) {
            // Remove avatar image and show initial
            if (currentAvatar) {
              currentAvatar.remove()
            }
            if (avatarInitial) {
              avatarInitial.style.display = 'block'
            }

            // Update overlay to remove the remove button
            if (avatarUploadOverlay) {
              avatarUploadOverlay.innerHTML =
                '<span class="text-white text-xs font-medium">üì∑ Upload</span>'
            }

            showMessage('Avatar removed successfully!', 'success')
          } else {
            showMessage(result.error || 'Failed to remove avatar', 'error')
          }
        } catch (error) {
          console.error('Error removing avatar:', error)
          showMessage('Network error. Please try again.', 'error')
        }
      })

      // Handle file selection
      avatarInput?.addEventListener('change', async e => {
        const file = (e.target as HTMLInputElement).files?.[0]
        if (!file) {
          return
        }

        // Validate file type
        if (!file.type.startsWith('image/')) {
          showMessage('Please select an image file', 'error')
          return
        }

        // Validate file size (5MB)
        if (file.size > 5 * 1024 * 1024) {
          showMessage('File size must be less than 5MB', 'error')
          return
        }

        // Show cropping modal
        showCropModal(file)
      })

      // Show crop modal
      function showCropModal(file: File) {
        // Clean up any existing cropper first
        if (cropper && typeof cropper.destroy === 'function') {
          try {
            cropper.destroy()
          } catch (error) {
            console.warn('Error destroying existing cropper:', error)
          }
          cropper = null
        }

        const reader = new FileReader()
        reader.onload = e => {
          if (cropImage && e.target?.result) {
            cropImage.src = e.target.result as string
            cropImage.style.display = 'block'
            cropModal?.classList.remove('hidden')
            cropModal?.classList.add('flex')

            // Wait for image to load before initializing cropper
            cropImage.onload = () => {
              // Initialize cropper with minimal configuration
              import('cropperjs')
                .then(({ default: Cropper }) => {
                  try {
                    cropper = new Cropper(cropImage, {
                      aspectRatio: 1,
                      viewMode: 1, // Restrict crop box to not exceed the size of the canvas
                      dragMode: 'move',
                      autoCropArea: 1, // Make crop area fill 100% of available space
                      restore: false,
                      guides: true,
                      center: true,
                      highlight: false,
                      cropBoxMovable: true,
                      cropBoxResizable: true,
                      toggleDragModeOnDblclick: false,
                      responsive: true,
                      checkOrientation: false,
                      background: true,
                      modal: true,
                      scalable: true,
                      zoomable: true,
                      rotatable: false,
                      // Ensure canvas fills container
                      minCanvasWidth: 480,
                      minCanvasHeight: 480,
                      ready: function () {
                        // Auto-fit image to fill container when ready
                        const containerData = this.cropper.getContainerData()
                        const imageData = this.cropper.getImageData()

                        if (
                          containerData &&
                          imageData &&
                          imageData.naturalWidth &&
                          imageData.naturalHeight
                        ) {
                          // Calculate scale to make image fill the container (minimum 80% coverage)
                          const scaleX =
                            (containerData.width * 0.9) / imageData.naturalWidth
                          const scaleY =
                            (containerData.height * 0.9) /
                            imageData.naturalHeight
                          const scale = Math.max(scaleX, scaleY, 0.8) // Minimum scale

                          // Apply the scale to fill container better
                          this.cropper.zoomTo(scale)
                        }
                      },
                    } as any)
                  } catch (error) {
                    console.error('Error creating cropper:', error)
                    showMessage('Failed to initialize image cropper', 'error')
                    closeCropModal()
                  }
                })
                .catch(error => {
                  console.error('Error loading cropper library:', error)
                  showMessage('Failed to load image cropper', 'error')
                  closeCropModal()
                })
            }
          }
        }
        reader.readAsDataURL(file)
      }

      // Handle crop cancel
      cropCancelBtn?.addEventListener('click', () => {
        closeCropModal()
      })

      // Handle crop apply
      cropApplyBtn?.addEventListener('click', async () => {
        if (!cropper || typeof cropper.getCroppedCanvas !== 'function') {
          showMessage('Cropper not properly initialized', 'error')
          return
        }

        try {
          // Show loading state
          if (cropApplyBtn) {
            cropApplyBtn.textContent = '‚è≥ Processing...'
            cropApplyBtn.disabled = true
          }

          // Get cropped canvas at original quality
          const canvas = cropper.getCroppedCanvas({
            width: 512,
            height: 512,
            imageSmoothingEnabled: true,
            imageSmoothingQuality: 'high',
          })

          // Convert to blob
          canvas.toBlob(
            async blob => {
              if (!blob) {
                showMessage('Failed to process image', 'error')
                return
              }

              // Create form data with cropped image
              const formData = new FormData()
              formData.append('avatar', blob, 'avatar.png')

              try {
                // Upload avatar
                const response = await fetch('/api/user/avatar', {
                  method: 'POST',
                  body: formData,
                })

                const result = await response.json()

                if (response.ok && result.success) {
                  // Update avatar display
                  if (currentAvatar) {
                    currentAvatar.src = result.avatar
                    currentAvatar.style.display = 'block'
                  } else {
                    // Create new image element if it doesn't exist
                    const newImg = document.createElement('img')
                    newImg.src = result.avatar
                    newImg.alt = 'User avatar'
                    newImg.className = 'w-full h-full object-cover'
                    newImg.id = 'current-avatar'

                    // Hide initial and add image
                    if (avatarInitial) {
                      avatarInitial.style.display = 'none'
                    }
                    avatarDisplay?.appendChild(newImg)
                  }

                  // Hide initial if it exists
                  if (avatarInitial) {
                    avatarInitial.style.display = 'none'
                  }

                  // Update overlay to include remove button
                  if (avatarUploadOverlay) {
                    avatarUploadOverlay.innerHTML = `
                    <span class="text-white text-xs font-medium mb-1">üì∑ Upload</span>
                    <button 
                      id="remove-avatar-btn"
                      class="text-red-400 text-xs font-medium hover:text-red-300 transition-colors"
                      type="button"
                    >
                      üóëÔ∏è Remove
                    </button>
                  `
                    // Re-attach event listener for new remove button
                    const newRemoveBtn =
                      document.getElementById('remove-avatar-btn')
                    newRemoveBtn?.addEventListener('click', async e => {
                      e.stopPropagation()

                      if (
                        !confirm('Are you sure you want to remove your avatar?')
                      ) {
                        return
                      }

                      try {
                        const response = await fetch('/api/user/avatar', {
                          method: 'DELETE',
                        })

                        const result = await response.json()

                        if (response.ok && result.success) {
                          // Remove avatar image and show initial
                          if (currentAvatar) {
                            currentAvatar.remove()
                          }
                          if (avatarInitial) {
                            avatarInitial.style.display = 'block'
                          }

                          // Update overlay to remove the remove button
                          if (avatarUploadOverlay) {
                            avatarUploadOverlay.innerHTML =
                              '<span class="text-white text-xs font-medium">üì∑ Upload</span>'
                          }

                          showMessage('Avatar removed successfully!', 'success')
                        } else {
                          showMessage(
                            result.error || 'Failed to remove avatar',
                            'error'
                          )
                        }
                      } catch (error) {
                        console.error('Error removing avatar:', error)
                        showMessage('Network error. Please try again.', 'error')
                      }
                    })
                  }

                  closeCropModal()
                  showMessage('Avatar updated successfully!', 'success')
                } else {
                  showMessage(
                    result.error || 'Failed to update avatar',
                    'error'
                  )
                }
              } catch (error) {
                console.error('Error uploading avatar:', error)
                showMessage('Network error. Please try again.', 'error')
              }
            },
            'image/png',
            0.9
          )
        } catch (error) {
          console.error('Error processing image:', error)
          showMessage('Failed to process image', 'error')
        } finally {
          // Reset button
          if (cropApplyBtn) {
            cropApplyBtn.textContent = 'Apply Crop'
            cropApplyBtn.disabled = false
          }
        }
      })

      // Close crop modal
      function closeCropModal() {
        // Hide modal first
        cropModal?.classList.add('hidden')
        cropModal?.classList.remove('flex')

        // Destroy cropper instance completely
        if (cropper) {
          try {
            if (typeof cropper.destroy === 'function') {
              cropper.destroy()
            }
          } catch (error) {
            console.warn('Error destroying cropper:', error)
          }
          cropper = null
        }

        // Complete cleanup of crop container
        if (cropContainer) {
          // Remove all cropper-generated elements
          const cropperElements = cropContainer.querySelectorAll(
            '.cropper-container, .cropper-canvas, .cropper-drag-box, .cropper-crop-box, .cropper-view-box, .cropper-dashed, .cropper-center'
          )
          cropperElements.forEach(el => {
            try {
              el.remove()
            } catch (error) {
              console.warn('Error removing cropper element:', error)
            }
          })

          // Reset container content to just the image
          cropContainer.innerHTML =
            '<img id="crop-image" style="display: none;" />'

          // Re-get the image element reference after resetting container
          cropImage = document.getElementById('crop-image') as HTMLImageElement
        }

        // Reset image element completely
        if (cropImage) {
          cropImage.style.display = 'none'
          cropImage.src = ''
          cropImage.onload = null
          cropImage.onerror = null

          // Remove any inline styles that cropper might have added
          cropImage.removeAttribute('style')
          cropImage.style.display = 'none'
        }

        // Clear file input
        if (avatarInput) {
          avatarInput.value = ''
        }

        // Force garbage collection hint
        if (window.gc) {
          window.gc()
        }
      }

      // Close modal on escape key
      document.addEventListener('keydown', e => {
        if (e.key === 'Escape' && !cropModal?.classList.contains('hidden')) {
          closeCropModal()
        }
      })
    })

    // Show message function
    function showMessage(message: string, type: string = 'info') {
      // Create message element
      const messageEl = document.createElement('div')
      messageEl.className = `fixed top-4 right-4 z-50 px-4 py-2 rounded-lg text-white font-medium transform translate-x-full transition-transform duration-300 ${
        type === 'success'
          ? 'bg-green-500/90'
          : type === 'error'
            ? 'bg-red-500/90'
            : 'bg-blue-500/90'
      }`
      messageEl.textContent = message

      document.body.appendChild(messageEl)

      // Animate in
      setTimeout(() => {
        messageEl.classList.remove('translate-x-full')
      }, 100)

      // Remove after 3 seconds
      setTimeout(() => {
        messageEl.classList.add('translate-x-full')
        setTimeout(() => {
          document.body.removeChild(messageEl)
        }, 300)
      }, 3000)
    }
  </script>

  <!-- Image Cropping Modal -->
  <div
    id="crop-modal"
    class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 hidden items-center justify-center p-4"
  >
    <div
      class="bg-gray-900 rounded-lg border border-cyan-400/30 p-6 max-w-2xl w-full max-h-[90vh] overflow-y-auto"
    >
      <h3
        class="text-xl font-orbitron font-bold text-holographic mb-4 text-center"
      >
        Crop Your Avatar
      </h3>

      <!-- Crop container -->
      <div class="mb-4">
        <div
          id="crop-container"
          class="w-full h-[500px] bg-gray-800 rounded-lg overflow-hidden"
        >
          <img id="crop-image" style="display: none;" />
        </div>
      </div>

      <!-- Crop controls -->
      <div class="flex gap-3 justify-center">
        <button
          id="crop-cancel-btn"
          class="px-4 py-2 bg-gray-600 hover:bg-gray-500 text-white rounded-lg transition-colors"
        >
          Cancel
        </button>
        <button
          id="crop-apply-btn"
          class="px-4 py-2 bg-gradient-to-r from-cyan-500 to-purple-600 hover:from-cyan-600 hover:to-purple-700 text-white rounded-lg transition-all"
        >
          Apply Crop
        </button>
      </div>
    </div>
  </div>
</AppLayout>
